/*---------------------------------------------------------------
RingBuffer

----------------------------------------------------------------*/
#ifndef __RING_BUFFER__
#define __RING_BUFFER__
#include <Windows.h>

namespace mylib
{
	class CRingBuffer
	{
	public:
		enum en_RING_BUFFER
		{
			en_BUFFER_DEFALUT = 3000,
		};

		CRingBuffer(int iBufferSize = en_BUFFER_DEFALUT);
		virtual ~CRingBuffer();


		/////////////////////////////////////////////////////////////////////////
		// 버퍼의 모든 데이터 삭제
		//
		/////////////////////////////////////////////////////////////////////////
		void	Clear();


		/////////////////////////////////////////////////////////////////////////
		// 락, 언락
		//
		/////////////////////////////////////////////////////////////////////////
		//  Enqueue(), Dequeue() 내부에서 알아서 Lock, Unlock 을 해주는 방법도 있지만
		// 사용자에게 맡기는 편이 성능면이나 확장성이 용이함.
		void	Lock();
		void	Unlock();


		//////////////////////////////////////////////////////////////////////////
		// 버퍼 크기
		//
		// Parameters: 
		// Return: (int)패킷 버퍼 크기
		//////////////////////////////////////////////////////////////////////////
		int		GetBufferSize() { return _iBufferSize; }


		//////////////////////////////////////////////////////////////////////////
		// 현재 사용 중인 크기
		//
		// Parameters: 
		// Return: (int)사용중인 데이터 크기
		//////////////////////////////////////////////////////////////////////////
		int		GetUseSize();


		/////////////////////////////////////////////////////////////////////////
		// 현재 버퍼에 남은 크기
		//
		// Parameters: 
		// Return: (int)남은 크기
		/////////////////////////////////////////////////////////////////////////
		int		GetFreeSize();


		/////////////////////////////////////////////////////////////////////////
		// 메모리상에서 끊기지 않고 입출력할 수 있는 최대 크기
		//
		// Parameters: 
		// Return: (int)사용가능 크기
		////////////////////////////////////////////////////////////////////////
		int		GetUnbrokenDequeueSize();
		int		GetUnbrokenEnqueueSize();


		//////////////////////////////////////////////////////////////////////////
		// 데이터 입력 :: WritePos 이동
		//
		// Parameters: (char *)SrcPtr (int)SrcSize
		// Return: (int)입력된 크기
		//////////////////////////////////////////////////////////////////////////
		int		Enqueue(char *chpData, int iSize);


		//////////////////////////////////////////////////////////////////////////
		// 데이터 출력 :: ReadPos 이동
		//
		// Parameters: (char *)DestPtr (int)Size
		// Return: (int)출력한 크기
		//////////////////////////////////////////////////////////////////////////
		int		Dequeue(char *pDest, int iSize);


		/////////////////////////////////////////////////////////////////////////
		// 읽기 포인터(ReadPos) 기준으로 출력 :: ReadPos 부동
		//
		// Parameters: (char *)데이터Ptr (int)Size
		// Return: (int)출력한 크기
		/////////////////////////////////////////////////////////////////////////
		int		Peek(char *pDest, int iSize);


		/////////////////////////////////////////////////////////////////////////
		// 입력한 크기만큼 WritePos 이동
		//
		/////////////////////////////////////////////////////////////////////////
		int		MoveWritePos(int iSize);


		/////////////////////////////////////////////////////////////////////////
		// 입력한 크기만큼 ReadPos 이동
		//
		/////////////////////////////////////////////////////////////////////////
		void	MoveReadPos(int iSize);


		/////////////////////////////////////////////////////////////////////////
		// 버퍼 포인터
		//
		// Parameters: 
		// Return: (char *) BufferPtr
		/////////////////////////////////////////////////////////////////////////
		char*	GetBufferPtr();


		/////////////////////////////////////////////////////////////////////////
		// 버퍼 ReadPos 포인터
		//
		// Parameters: 
		// Return: (char *) BufferPtr
		/////////////////////////////////////////////////////////////////////////
		char*	GetReadBufferPtr();


		/////////////////////////////////////////////////////////////////////////
		// 버퍼 WritePos 포인터
		//
		// Parameters:
		// Return: (char *) BufferPtr
		/////////////////////////////////////////////////////////////////////////
		char*	GetWriteBufferPtr();


	private:
		// BUFFER
		char*		_pBuffer;
		int			_iRead;
		int			_iWrite;

		// MONITOR
		int			_iBufferSize;

		// OPTION
		SRWLOCK		_srwLock;
	};
}
#endif 